<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Racing Game - First Person</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            cursor: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 50%, #8FBC8F 100%);
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Courier New', monospace;
        }

        #score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }

        #speed {
            font-size: 18px;
            margin-bottom: 10px;
            color: #FF6B6B;
        }

        #bestScore {
            font-size: 16px;
            opacity: 0.8;
            color: #4ECDC4;
        }

        #madeBy {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            display: none;
            border: 2px solid #FFD700;
        }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            border: 2px solid #FF6B6B;
        }

        .btn {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            background: linear-gradient(45deg, #FF8E53, #FF6B6B);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 50;
            pointer-events: none;
        }

        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            z-index: 100;
            font-size: 12px;
            opacity: 0.7;
        }

        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            z-index: 100;
        }

        #speedometer canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="score">–°—á—ë—Ç: 0</div>
        <div id="speed">–°–∫–æ—Ä–æ—Å—Ç—å: 0 –∫–º/—á</div>
        <div id="bestScore">–õ—É—á—à–∏–π: 0</div>
    </div>
    
    <div id="madeBy">Made by KakDibo</div>
    <div id="crosshair"></div>
    
    <div id="speedometer">
        <canvas id="speedCanvas"></canvas>
    </div>
    
    <div id="controls">
        WASD / –°—Ç—Ä–µ–ª–∫–∏ - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ<br>
        –ú—ã—à—å - –ü–æ–≤–æ—Ä–æ—Ç –∫–∞–º–µ—Ä—ã
    </div>
    
    <div id="startScreen">
        <h1>üèéÔ∏è 3D Racing Game</h1>
        <p>–†–µ–∞–ª–∏—Å—Ç–∏—á–Ω–∞—è –≥–æ–Ω–æ—á–Ω–∞—è –∏–≥—Ä–∞ –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞</p>
        <p>–£–ø—Ä–∞–≤–ª—è–π—Ç–µ –∫—Ä–∞—Å–Ω—ã–º –º–∞—Å–ª –∫–∞—Ä–æ–º –∏ –∏–∑–±–µ–≥–∞–π—Ç–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π!</p>
        <button class="btn" onclick="startGame()">üéÆ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    </div>
    
    <div id="gameOver">
        <h2>üí• –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
        <p>–í–∞—à —Å—á—ë—Ç: <span id="finalScore">0</span></p>
        <p>–õ—É—á—à–∏–π —Å—á—ë—Ç: <span id="finalBestScore">0</span></p>
        <button class="btn" onclick="restartGame()">üîÑ –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        <button class="btn" onclick="closeWebApp()">üè† –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –±–æ—Ç–∞</button>
    </div>

    <script>
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram Web App
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        // WebGL –∫–æ–Ω—Ç–µ–∫—Å—Ç
        let gl;
        let canvas;
        let program;
        let gameRunning = false;
        let score = 0;
        let bestScore = localStorage.getItem('racing3DBestScore') || 0;
        let speed = 0;
        let maxSpeed = 200;
        let acceleration = 0;
        let carPosition = { x: 0, y: 0, z: 0 };
        let carRotation = 0;
        let cameraRotation = 0;
        let obstacles = [];
        let roadSegments = [];
        let lastTime = 0;
        let keys = {};

        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let gameSpeed = 1;
        let lastObstacleTime = 0;
        let roadWidth = 20;
        let segmentLength = 200;
        let segmentsCount = 20;

        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const scoreElement = document.getElementById('score');
        const speedElement = document.getElementById('speed');
        const bestScoreElement = document.getElementById('bestScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const finalBestScoreElement = document.getElementById('finalBestScore');
        const speedCanvas = document.getElementById('speedCanvas');

        // –û–±–Ω–æ–≤–ª—è–µ–º –ª—É—á—à–∏–π —Å—á—ë—Ç
        bestScoreElement.textContent = `–õ—É—á—à–∏–π: ${bestScore}`;

        // –®–µ–π–¥–µ—Ä—ã
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;
            attribute vec2 a_texCoord;
            
            uniform mat4 u_modelViewMatrix;
            uniform mat4 u_projectionMatrix;
            uniform mat4 u_normalMatrix;
            
            varying vec3 v_normal;
            varying vec2 v_texCoord;
            varying vec3 v_position;
            
            void main() {
                v_position = vec3(u_modelViewMatrix * vec4(a_position, 1.0));
                v_normal = vec3(u_normalMatrix * vec4(a_normal, 0.0));
                v_texCoord = a_texCoord;
                gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_position, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            
            varying vec3 v_normal;
            varying vec2 v_texCoord;
            varying vec3 v_position;
            
            uniform vec3 u_lightPosition;
            uniform vec3 u_viewPosition;
            uniform vec3 u_ambientColor;
            uniform vec3 u_diffuseColor;
            uniform vec3 u_specularColor;
            uniform float u_shininess;
            
            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(u_lightPosition - v_position);
                vec3 viewDir = normalize(u_viewPosition - v_position);
                vec3 reflectDir = reflect(-lightDir, normal);
                
                float diff = max(dot(normal, lightDir), 0.0);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), u_shininess);
                
                vec3 ambient = u_ambientColor;
                vec3 diffuse = diff * u_diffuseColor;
                vec3 specular = spec * u_specularColor;
                
                gl_FragColor = vec4(ambient + diffuse + specular, 1.0);
            }
        `;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WebGL
        function initWebGL() {
            canvas = document.getElementById('gameCanvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                alert('WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è!');
                return;
            }

            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ canvas
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã
            program = createProgram(vertexShaderSource, fragmentShaderSource);
            gl.useProgram(program);

            // –ü–æ–ª—É—á–µ–Ω–∏–µ uniform –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
            window.u_modelViewMatrix = gl.getUniformLocation(program, 'u_modelViewMatrix');
            window.u_projectionMatrix = gl.getUniformLocation(program, 'u_projectionMatrix');
            window.u_normalMatrix = gl.getUniformLocation(program, 'u_normalMatrix');
            window.u_lightPosition = gl.getUniformLocation(program, 'u_lightPosition');
            window.u_viewPosition = gl.getUniformLocation(program, 'u_viewPosition');
            window.u_ambientColor = gl.getUniformLocation(program, 'u_ambientColor');
            window.u_diffuseColor = gl.getUniformLocation(program, 'u_diffuseColor');
            window.u_specularColor = gl.getUniformLocation(program, 'u_specularColor');
            window.u_shininess = gl.getUniformLocation(program, 'u_shininess');

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ OpenGL
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.clearColor(0.5, 0.7, 1.0, 1.0);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —à–µ–π–¥–µ—Ä–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã
        function createProgram(vertexSource, fragmentSource) {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentSource);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('–û—à–∏–±–∫–∞ –ª–∏–Ω–∫–æ–≤–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã:', gl.getProgramInfoLog(program));
                return null;
            }
            
            return program;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —à–µ–π–¥–µ—Ä–∞
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —à–µ–π–¥–µ—Ä–∞:', gl.getShaderInfoLog(shader));
                return null;
            }
            
            return shader;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –±—É—Ñ–µ—Ä–∞
        function createBuffer(data) {
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
            return buffer;
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –º–∞—à–∏–Ω—ã (–º–∞—Å–ª –∫–∞—Ä)
        function createCarGeometry() {
            const vertices = [
                // –ö—É–∑–æ–≤ (–∫—Ä–∞—Å–Ω—ã–π)
                -2.0, -0.5, -4.0,  2.0, -0.5, -4.0,  2.0,  1.0, -4.0, -2.0,  1.0, -4.0, // –∑–∞–¥
                -2.0, -0.5,  4.0,  2.0, -0.5,  4.0,  2.0,  1.0,  4.0, -2.0,  1.0,  4.0, // –ø–µ—Ä–µ–¥
                -2.0, -0.5, -4.0, -2.0, -0.5,  4.0, -2.0,  1.0,  4.0, -2.0,  1.0, -4.0, // –ª–µ–≤–∞—è
                 2.0, -0.5, -4.0,  2.0, -0.5,  4.0,  2.0,  1.0,  4.0,  2.0,  1.0, -4.0, // –ø—Ä–∞–≤–∞—è
                -2.0,  1.0, -4.0,  2.0,  1.0, -4.0,  2.0,  1.0,  4.0, -2.0,  1.0,  4.0, // –∫—Ä—ã—à–∞
                
                // –ö–∞–ø–æ—Ç (–±–æ–ª–µ–µ —Ç–µ–º–Ω—ã–π –∫—Ä–∞—Å–Ω—ã–π)
                -1.5,  1.0,  4.0,  1.5,  1.0,  4.0,  1.5,  1.5,  5.0, -1.5,  1.5,  5.0,
                
                // –ö–æ–ª–µ—Å–∞
                -2.5, -0.5, -3.0, -1.5, -0.5, -3.0, -1.5,  0.5, -3.0, -2.5,  0.5, -3.0, // –ª–µ–≤–æ–µ –∑–∞–¥–Ω–µ–µ
                 1.5, -0.5, -3.0,  2.5, -0.5, -3.0,  2.5,  0.5, -3.0,  1.5,  0.5, -3.0, // –ø—Ä–∞–≤–æ–µ –∑–∞–¥–Ω–µ–µ
                -2.5, -0.5,  3.0, -1.5, -0.5,  3.0, -1.5,  0.5,  3.0, -2.5,  0.5,  3.0, // –ª–µ–≤–æ–µ –ø–µ—Ä–µ–¥–Ω–µ–µ
                 1.5, -0.5,  3.0,  2.5, -0.5,  3.0,  2.5,  0.5,  3.0,  1.5,  0.5,  3.0, // –ø—Ä–∞–≤–æ–µ –ø–µ—Ä–µ–¥–Ω–µ–µ
            ];

            const normals = [];
            for (let i = 0; i < vertices.length; i += 12) {
                const v1 = [vertices[i+3] - vertices[i], vertices[i+4] - vertices[i+1], vertices[i+5] - vertices[i+2]];
                const v2 = [vertices[i+6] - vertices[i], vertices[i+7] - vertices[i+1], vertices[i+8] - vertices[i+2]];
                const normal = crossProduct(v1, v2);
                for (let j = 0; j < 4; j++) {
                    normals.push(...normal);
                }
            }

            return {
                vertices: createBuffer(vertices),
                normals: createBuffer(normals),
                vertexCount: vertices.length / 3
            };
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
        function createObstacleGeometry(type) {
            let vertices = [];
            
            switch(type) {
                case 'box':
                    vertices = [
                        -1.0, -1.0, -1.0,  1.0, -1.0, -1.0,  1.0,  1.0, -1.0, -1.0,  1.0, -1.0,
                        -1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0, -1.0,  1.0,  1.0,
                        -1.0, -1.0, -1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0, -1.0,  1.0, -1.0,
                         1.0, -1.0, -1.0,  1.0, -1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0, -1.0,
                        -1.0,  1.0, -1.0,  1.0,  1.0, -1.0,  1.0,  1.0,  1.0, -1.0,  1.0,  1.0,
                    ];
                    break;
                case 'tire':
                    // –¶–∏–ª–∏–Ω–¥—Ä –¥–ª—è —à–∏–Ω—ã
                    const segments = 16;
                    for (let i = 0; i < segments; i++) {
                        const angle1 = (i / segments) * 2 * Math.PI;
                        const angle2 = ((i + 1) / segments) * 2 * Math.PI;
                        const x1 = Math.cos(angle1), z1 = Math.sin(angle1);
                        const x2 = Math.cos(angle2), z2 = Math.sin(angle2);
                        
                        vertices.push(
                            x1, -0.5, z1,  x2, -0.5, z2,  x2,  0.5, z2,  x1,  0.5, z1,
                            x1, -0.5, z1,  x1,  0.5, z1,  x2,  0.5, z2,  x2, -0.5, z2
                        );
                    }
                    break;
                case 'person':
                    // –ß–µ–ª–æ–≤–µ–∫ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å)
                    vertices = [
                        // –ì–æ–ª–æ–≤–∞
                        -0.3,  1.5, -0.3,  0.3,  1.5, -0.3,  0.3,  2.0, -0.3, -0.3,  2.0, -0.3,
                        -0.3,  1.5,  0.3,  0.3,  1.5,  0.3,  0.3,  2.0,  0.3, -0.3,  2.0,  0.3,
                        // –¢–µ–ª–æ
                        -0.5,  0.0, -0.3,  0.5,  0.0, -0.3,  0.5,  1.5, -0.3, -0.5,  1.5, -0.3,
                        -0.5,  0.0,  0.3,  0.5,  0.0,  0.3,  0.5,  1.5,  0.3, -0.5,  1.5,  0.3,
                        // –†—É–∫–∏
                        -0.8,  1.0, -0.2, -0.5,  1.0, -0.2, -0.5,  1.5, -0.2, -0.8,  1.5, -0.2,
                         0.5,  1.0, -0.2,  0.8,  1.0, -0.2,  0.8,  1.5, -0.2,  0.5,  1.5, -0.2,
                        // –ù–æ–≥–∏
                        -0.3, -1.0, -0.2,  0.0, -1.0, -0.2,  0.0,  0.0, -0.2, -0.3,  0.0, -0.2,
                         0.0, -1.0, -0.2,  0.3, -1.0, -0.2,  0.3,  0.0, -0.2,  0.0,  0.0, -0.2,
                    ];
                    break;
                case 'other-car':
                    // –î—Ä—É–≥–∞—è –º–∞—à–∏–Ω–∞ (–∂–µ–ª—Ç–∞—è)
                    vertices = [
                        -1.5, -0.5, -3.0,  1.5, -0.5, -3.0,  1.5,  0.8, -3.0, -1.5,  0.8, -3.0,
                        -1.5, -0.5,  3.0,  1.5, -0.5,  3.0,  1.5,  0.8,  3.0, -1.5,  0.8,  3.0,
                        -1.5, -0.5, -3.0, -1.5, -0.5,  3.0, -1.5,  0.8,  3.0, -1.5,  0.8, -3.0,
                         1.5, -0.5, -3.0,  1.5, -0.5,  3.0,  1.5,  0.8,  3.0,  1.5,  0.8, -3.0,
                        -1.5,  0.8, -3.0,  1.5,  0.8, -3.0,  1.5,  0.8,  3.0, -1.5,  0.8,  3.0,
                    ];
                    break;
            }

            const normals = [];
            for (let i = 0; i < vertices.length; i += 12) {
                const v1 = [vertices[i+3] - vertices[i], vertices[i+4] - vertices[i+1], vertices[i+5] - vertices[i+2]];
                const v2 = [vertices[i+6] - vertices[i], vertices[i+7] - vertices[i+1], vertices[i+8] - vertices[i+2]];
                const normal = crossProduct(v1, v2);
                for (let j = 0; j < 4; j++) {
                    normals.push(...normal);
                }
            }

            return {
                vertices: createBuffer(vertices),
                normals: createBuffer(normals),
                vertexCount: vertices.length / 3
            };
        }

        // –í–µ–∫—Ç–æ—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
        function crossProduct(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü
        function createProjectionMatrix(fov, aspect, near, far) {
            const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
            const rangeInv = 1.0 / (near - far);
            
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ];
        }

        function createModelViewMatrix(translation, rotation) {
            const cos = Math.cos(rotation);
            const sin = Math.sin(rotation);
            
            return [
                cos, 0, sin, 0,
                0, 1, 0, 0,
                -sin, 0, cos, 0,
                translation[0], translation[1], translation[2], 1
            ];
        }

        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (gameRunning) {
                cameraRotation += e.movementX * 0.01;
                cameraRotation = Math.max(-0.5, Math.min(0.5, cameraRotation));
            }
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                document.addEventListener('mousemove', (e) => {
                    if (gameRunning) {
                        cameraRotation += e.movementX * 0.01;
                        cameraRotation = Math.max(-0.5, Math.min(0.5, cameraRotation));
                    }
                });
            }
        });

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function updateControls(deltaTime) {
            if (keys['KeyA'] || keys['ArrowLeft']) {
                carPosition.x -= 50 * deltaTime;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                carPosition.x += 50 * deltaTime;
            }
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –ø–æ –¥–æ—Ä–æ–≥–µ
            carPosition.x = Math.max(-roadWidth/2 + 2, Math.min(roadWidth/2 - 2, carPosition.x));
            
            // –£—Å–∫–æ—Ä–µ–Ω–∏–µ
            if (keys['KeyW'] || keys['ArrowUp']) {
                acceleration = Math.min(acceleration + 100 * deltaTime, 200);
            } else if (keys['KeyS'] || keys['ArrowDown']) {
                acceleration = Math.max(acceleration - 200 * deltaTime, -50);
            } else {
                acceleration = Math.max(acceleration - 50 * deltaTime, 0);
            }
            
            speed = Math.max(0, Math.min(maxSpeed, speed + acceleration * deltaTime));
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        function createObstacle() {
            const types = ['box', 'tire', 'person', 'other-car'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const x = (Math.random() - 0.5) * (roadWidth - 4);
            const z = carPosition.z - 100 - Math.random() * 50;
            
            obstacles.push({
                type: type,
                position: [x, 0, z],
                geometry: createObstacleGeometry(type),
                hitbox: {
                    min: [x - 1, 0, z - 1],
                    max: [x + 1, 2, z + 1]
                }
            });
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        function checkCollisions() {
            const carHitbox = {
                min: [carPosition.x - 1.5, carPosition.y, carPosition.z - 2],
                max: [carPosition.x + 1.5, carPosition.y + 1, carPosition.z + 2]
            };
            
            for (let obstacle of obstacles) {
                if (carHitbox.max[0] > obstacle.hitbox.min[0] &&
                    carHitbox.min[0] < obstacle.hitbox.max[0] &&
                    carHitbox.max[1] > obstacle.hitbox.min[1] &&
                    carHitbox.min[1] < obstacle.hitbox.max[1] &&
                    carHitbox.max[2] > obstacle.hitbox.min[2] &&
                    carHitbox.min[2] < obstacle.hitbox.max[2]) {
                    return true;
                }
            }
            return false;
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
        function updateObstacles(deltaTime) {
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position[2] += speed * deltaTime;
                
                if (obstacle.position[2] > carPosition.z + 10) {
                    obstacles.splice(i, 1);
                    score++;
                    scoreElement.textContent = `–°—á—ë—Ç: ${score}`;
                }
            }
        }

        // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
        function render() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            const aspect = canvas.width / canvas.height;
            const projectionMatrix = createProjectionMatrix(Math.PI / 4, aspect, 0.1, 1000);
            gl.uniformMatrix4fv(window.u_projectionMatrix, false, projectionMatrix);
            
            // –ö–∞–º–µ—Ä–∞ –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞
            const cameraMatrix = createModelViewMatrix([0, 1.5, 0], cameraRotation);
            gl.uniformMatrix4fv(window.u_modelViewMatrix, false, cameraMatrix);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            gl.uniform3f(window.u_lightPosition, 0, 10, 0);
            gl.uniform3f(window.u_viewPosition, 0, 1.5, 0);
            gl.uniform3f(window.u_ambientColor, 0.2, 0.2, 0.2);
            gl.uniform3f(window.u_diffuseColor, 0.8, 0.8, 0.8);
            gl.uniform3f(window.u_specularColor, 1.0, 1.0, 1.0);
            gl.uniform1f(window.u_shininess, 32.0);
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –¥–æ—Ä–æ–≥–∏
            renderRoad();
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            for (let obstacle of obstacles) {
                renderObstacle(obstacle);
            }
        }

        function renderRoad() {
            // –ü—Ä–æ—Å—Ç–∞—è –¥–æ—Ä–æ–≥–∞ —Å –ø–æ–ª–æ—Å–∞–º–∏
            const roadGeometry = {
                vertices: createBuffer([
                    -roadWidth/2, 0, -100,  roadWidth/2, 0, -100,  roadWidth/2, 0, 100, -roadWidth/2, 0, 100
                ]),
                normals: createBuffer([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]),
                vertexCount: 4
            };
            
            gl.uniform3f(window.u_diffuseColor, 0.3, 0.3, 0.3);
            renderGeometry(roadGeometry);
        }

        function renderObstacle(obstacle) {
            const modelMatrix = createModelViewMatrix(obstacle.position, 0);
            gl.uniformMatrix4fv(window.u_modelViewMatrix, false, modelMatrix);
            
            switch(obstacle.type) {
                case 'box':
                    gl.uniform3f(window.u_diffuseColor, 0.6, 0.4, 0.2);
                    break;
                case 'tire':
                    gl.uniform3f(window.u_diffuseColor, 0.1, 0.1, 0.1);
                    break;
                case 'person':
                    gl.uniform3f(window.u_diffuseColor, 0.2, 0.4, 0.8);
                    break;
                case 'other-car':
                    gl.uniform3f(window.u_diffuseColor, 1.0, 0.8, 0.0);
                    break;
            }
            
            renderGeometry(obstacle.geometry);
        }

        function renderGeometry(geometry) {
            gl.bindBuffer(gl.ARRAY_BUFFER, geometry.vertices);
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, geometry.normals);
            const normalLocation = gl.getAttribLocation(program, 'a_normal');
            gl.enableVertexAttribArray(normalLocation);
            gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.TRIANGLE_FAN, 0, geometry.vertexCount);
        }

        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop(currentTime) {
            if (!gameRunning) return;
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            updateControls(deltaTime);
            updateObstacles(deltaTime);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            if (currentTime - lastObstacleTime > 2000 / gameSpeed) {
                createObstacle();
                lastObstacleTime = currentTime;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            if (checkCollisions()) {
                gameOver();
                return;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
            gameSpeed = Math.floor(score / 10) + 1;
            speedElement.textContent = `–°–∫–æ—Ä–æ—Å—Ç—å: ${Math.round(speed)} –∫–º/—á`;
            
            render();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameRunning = true;
            score = 0;
            speed = 0;
            acceleration = 0;
            carPosition = { x: 0, y: 0, z: 0 };
            carRotation = 0;
            cameraRotation = 0;
            obstacles = [];
            gameSpeed = 1;
            
            scoreElement.textContent = '–°—á—ë—Ç: 0';
            speedElement.textContent = '–°–∫–æ—Ä–æ—Å—Ç—å: 0 –∫–º/—á';
            
            canvas.requestPointerLock();
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        function gameOver() {
            gameRunning = false;
            document.exitPointerLock();
            
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('racing3DBestScore', bestScore);
                bestScoreElement.textContent = `–õ—É—á—à–∏–π: ${bestScore}`;
            }
            
            finalScoreElement.textContent = score;
            finalBestScoreElement.textContent = bestScore;
            gameOverScreen.style.display = 'block';
            
            try {
                tg.sendData(JSON.stringify({
                    action: 'game_result',
                    score: score,
                    best_score: bestScore
                }));
            } catch (e) {
                console.log('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –±–æ—Ç–∞:', e);
            }
        }

        function restartGame() {
            gameOverScreen.style.display = 'none';
            startGame();
        }

        function closeWebApp() {
            try {
                tg.close();
            } catch (e) {
                console.log('–û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è Web App:', e);
                tg.sendData(JSON.stringify({
                    action: 'close_app'
                }));
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        initWebGL();
    </script>
</body>
</html> 